// Package jupiter provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.0.0 DO NOT EDIT.
package jupiter

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
)

// Defines values for SwapMode.
const (
	SwapModeExactIn  SwapMode = "ExactIn"
	SwapModeExactOut SwapMode = "ExactOut"
)

// Defines values for SwapRequestComputeUnitPriceMicroLamports1.
const (
	SwapRequestComputeUnitPriceMicroLamports1Auto SwapRequestComputeUnitPriceMicroLamports1 = "auto"
)

// Defines values for SwapRequestPrioritizationFeeLamports1.
const (
	SwapRequestPrioritizationFeeLamports1Auto SwapRequestPrioritizationFeeLamports1 = "auto"
)

// Defines values for SwapModeParameter.
const (
	SwapModeParameterExactIn  SwapModeParameter = "ExactIn"
	SwapModeParameterExactOut SwapModeParameter = "ExactOut"
)

// Defines values for GetQuoteParamsSwapMode.
const (
	ExactIn  GetQuoteParamsSwapMode = "ExactIn"
	ExactOut GetQuoteParamsSwapMode = "ExactOut"
)

// AccountMeta defines model for AccountMeta.
type AccountMeta struct {
	IsSigner   bool   `json:"isSigner"`
	IsWritable bool   `json:"isWritable"`
	Pubkey     string `json:"pubkey"`
}

// IndexedRouteMapResponse defines model for IndexedRouteMapResponse.
type IndexedRouteMapResponse struct {
	// IndexedRouteMap All the possible route and their corresponding output mints
	IndexedRouteMap map[string][]float32 `json:"indexedRouteMap"`

	// MintKeys All the mints that are indexed to match in indexedRouteMap
	MintKeys []string `json:"mintKeys"`
}

// Instruction defines model for Instruction.
type Instruction struct {
	Accounts  []AccountMeta `json:"accounts"`
	Data      string        `json:"data"`
	ProgramId string        `json:"programId"`
}

// PlatformFee defines model for PlatformFee.
type PlatformFee struct {
	Amount *string `json:"amount,omitempty"`
	FeeBps *int32  `json:"feeBps,omitempty"`
}

// QuoteResponse defines model for QuoteResponse.
type QuoteResponse struct {
	ContextSlot          *float32        `json:"contextSlot,omitempty"`
	InAmount             string          `json:"inAmount"`
	InputMint            string          `json:"inputMint"`
	OtherAmountThreshold string          `json:"otherAmountThreshold"`
	OutAmount            string          `json:"outAmount"`
	OutputMint           string          `json:"outputMint"`
	PlatformFee          *PlatformFee    `json:"platformFee,omitempty"`
	PriceImpactPct       string          `json:"priceImpactPct"`
	RoutePlan            []RoutePlanStep `json:"routePlan"`
	SlippageBps          int32           `json:"slippageBps"`
	SwapMode             SwapMode        `json:"swapMode"`
	TimeTaken            *float32        `json:"timeTaken,omitempty"`
}

// RoutePlanStep defines model for RoutePlanStep.
type RoutePlanStep struct {
	Percent  int32    `json:"percent"`
	SwapInfo SwapInfo `json:"swapInfo"`
}

// SwapInfo defines model for SwapInfo.
type SwapInfo struct {
	AmmKey     string  `json:"ammKey"`
	FeeAmount  string  `json:"feeAmount"`
	FeeMint    string  `json:"feeMint"`
	InAmount   string  `json:"inAmount"`
	InputMint  string  `json:"inputMint"`
	Label      *string `json:"label,omitempty"`
	OutAmount  string  `json:"outAmount"`
	OutputMint string  `json:"outputMint"`
}

// SwapInstructionsResponse defines model for SwapInstructionsResponse.
type SwapInstructionsResponse struct {
	// AddressLookupTableAddresses The lookup table addresses that you can use if you are using versioned transaction.
	AddressLookupTableAddresses []string     `json:"addressLookupTableAddresses"`
	CleanupInstruction          *Instruction `json:"cleanupInstruction,omitempty"`

	// ComputeBudgetInstructions The necessary instructions to setup the compute budget.
	ComputeBudgetInstructions []Instruction `json:"computeBudgetInstructions"`

	// SetupInstructions Setup missing ATA for the users.
	SetupInstructions      []Instruction `json:"setupInstructions"`
	SwapInstruction        Instruction   `json:"swapInstruction"`
	TokenLedgerInstruction *Instruction  `json:"tokenLedgerInstruction,omitempty"`
}

// SwapMode defines model for SwapMode.
type SwapMode string

// SwapRequest defines model for SwapRequest.
type SwapRequest struct {
	// AsLegacyTransaction Default is false. Request a legacy transaction rather than the default versioned transaction, needs to be paired with a quote using asLegacyTransaction otherwise the transaction might be too large.
	AsLegacyTransaction *bool `json:"asLegacyTransaction,omitempty"`

	// ComputeUnitPriceMicroLamports The compute unit price to prioritize the transaction, the additional fee will be `computeUnitLimit (1400000) * computeUnitPriceMicroLamports`. If `auto` is used, Jupiter will automatically set a priority fee and it will be capped at 5,000,000 lamports / 0.005 SOL.
	ComputeUnitPriceMicroLamports *SwapRequest_ComputeUnitPriceMicroLamports `json:"computeUnitPriceMicroLamports,omitempty"`

	// DestinationTokenAccount Public key of the token account that will be used to receive the token out of the swap. If not provided, the user's ATA will be used. If provided, we assume that the token account is already initialized.
	DestinationTokenAccount *string `json:"destinationTokenAccount,omitempty"`

	// DynamicComputeUnitLimit When enabled, it will do a swap simulation to get the compute unit used and set it in ComputeBudget's compute unit limit. This will increase latency slightly since there will be one extra RPC call to simulate this. Default is `false`.
	DynamicComputeUnitLimit *bool `json:"dynamicComputeUnitLimit,omitempty"`

	// FeeAccount Fee token account, same as the output token for ExactIn and as the input token for ExactOut, it is derived using the seeds = ["referral_ata", referral_account, mint] and the `REFER4ZgmyYx9c6He5XfaTMiGfdLwRnkV4RPp9t9iF3` referral contract (only pass in if you set a feeBps and make sure that the feeAccount has been created).
	FeeAccount *string `json:"feeAccount,omitempty"`

	// PrioritizationFeeLamports Prioritization fee lamports paid for the transaction in addition to the signatures fee. Mutually exclusive with compute_unit_price_micro_lamports. If `auto` is used, Jupiter will automatically set a priority fee and it will be capped at 5,000,000 lamports / 0.005 SOL.
	PrioritizationFeeLamports *SwapRequest_PrioritizationFeeLamports `json:"prioritizationFeeLamports,omitempty"`
	QuoteResponse             QuoteResponse                          `json:"quoteResponse"`

	// SkipUserAccountsRpcCalls When enabled, it will not do any rpc calls check on user's accounts. Enable it only when you already setup all the accounts needed for the trasaction, like wrapping or unwrapping sol, destination account is already created.
	SkipUserAccountsRpcCalls *bool `json:"skipUserAccountsRpcCalls,omitempty"`

	// UseSharedAccounts Default is true. This enables the usage of shared program accountns. That means no intermediate token accounts or open orders accounts need to be created for the users. But it also means that the likelihood of hot accounts is higher.
	UseSharedAccounts *bool `json:"useSharedAccounts,omitempty"`

	// UseTokenLedger Default is false. This is useful when the instruction before the swap has a transfer that increases the input token amount. Then, the swap will just use the difference between the token ledger token amount and post token amount.
	UseTokenLedger *bool `json:"useTokenLedger,omitempty"`

	// UserPublicKey The user public key.
	UserPublicKey string `json:"userPublicKey"`

	// WrapAndUnwrapSol Default is true. If true, will automatically wrap/unwrap SOL. If false, it will use wSOL token account.  Will be ignored if `destinationTokenAccount` is set because the `destinationTokenAccount` may belong to a different user that we have no authority to close.
	WrapAndUnwrapSol *bool `json:"wrapAndUnwrapSol,omitempty"`
}

// SwapRequestComputeUnitPriceMicroLamports0 defines model for .
type SwapRequestComputeUnitPriceMicroLamports0 = int

// SwapRequestComputeUnitPriceMicroLamports1 defines model for SwapRequest.ComputeUnitPriceMicroLamports.1.
type SwapRequestComputeUnitPriceMicroLamports1 string

// SwapRequest_ComputeUnitPriceMicroLamports The compute unit price to prioritize the transaction, the additional fee will be `computeUnitLimit (1400000) * computeUnitPriceMicroLamports`. If `auto` is used, Jupiter will automatically set a priority fee and it will be capped at 5,000,000 lamports / 0.005 SOL.
type SwapRequest_ComputeUnitPriceMicroLamports struct {
	union json.RawMessage
}

// SwapRequestPrioritizationFeeLamports0 defines model for .
type SwapRequestPrioritizationFeeLamports0 = int

// SwapRequestPrioritizationFeeLamports1 defines model for SwapRequest.PrioritizationFeeLamports.1.
type SwapRequestPrioritizationFeeLamports1 string

// SwapRequest_PrioritizationFeeLamports Prioritization fee lamports paid for the transaction in addition to the signatures fee. Mutually exclusive with compute_unit_price_micro_lamports. If `auto` is used, Jupiter will automatically set a priority fee and it will be capped at 5,000,000 lamports / 0.005 SOL.
type SwapRequest_PrioritizationFeeLamports struct {
	union json.RawMessage
}

// SwapResponse defines model for SwapResponse.
type SwapResponse struct {
	LastValidBlockHeight      float32  `json:"lastValidBlockHeight"`
	PrioritizationFeeLamports *float32 `json:"prioritizationFeeLamports,omitempty"`
	SwapTransaction           string   `json:"swapTransaction"`
}

// AmountParameter defines model for AmountParameter.
type AmountParameter = int

// AsLegacyTransactionParameter defines model for AsLegacyTransactionParameter.
type AsLegacyTransactionParameter = bool

// DexesParameter defines model for DexesParameter.
type DexesParameter = []string

// ExcludeDexesParameter defines model for ExcludeDexesParameter.
type ExcludeDexesParameter = []string

// InputMintParameter defines model for InputMintParameter.
type InputMintParameter = string

// MaxAccountsParameter defines model for MaxAccountsParameter.
type MaxAccountsParameter = int

// OnlyDirectRoutesParameter defines model for OnlyDirectRoutesParameter.
type OnlyDirectRoutesParameter = bool

// OutputMintParameter defines model for OutputMintParameter.
type OutputMintParameter = string

// PlatformFeeBpsParameter defines model for PlatformFeeBpsParameter.
type PlatformFeeBpsParameter = int

// RestrictIntermediateTokensParameter defines model for RestrictIntermediateTokensParameter.
type RestrictIntermediateTokensParameter = bool

// SlippageParameter defines model for SlippageParameter.
type SlippageParameter = int

// SwapModeParameter defines model for SwapModeParameter.
type SwapModeParameter string

// GetIndexedRouteMapParams defines parameters for GetIndexedRouteMap.
type GetIndexedRouteMapParams struct {
	// OnlyDirectRoutes Default is false. Direct Routes limits Jupiter routing to single hop routes only.
	OnlyDirectRoutes *OnlyDirectRoutesParameter `form:"onlyDirectRoutes,omitempty" json:"onlyDirectRoutes,omitempty"`
}

// GetQuoteParams defines parameters for GetQuote.
type GetQuoteParams struct {
	// InputMint Input token mint address
	InputMint InputMintParameter `form:"inputMint" json:"inputMint"`

	// OutputMint Output token mint address
	OutputMint OutputMintParameter `form:"outputMint" json:"outputMint"`

	// Amount The amount to swap, have to factor in the token decimals.
	Amount AmountParameter `form:"amount" json:"amount"`

	// SlippageBps The slippage in basis points, 1 basis point is 0.01%. If the output token amount exceeds the slippage then the swap transaction will fail.
	SlippageBps *SlippageParameter `form:"slippageBps,omitempty" json:"slippageBps,omitempty"`

	// SwapMode (ExactIn or ExactOut) Defaults to ExactIn. ExactOut is for supporting use cases where you need an exact token amount, like payments. In this case the slippage is on the input token.
	SwapMode *GetQuoteParamsSwapMode `form:"swapMode,omitempty" json:"swapMode,omitempty"`

	// Dexes Default is that all DEXes are included. You can pass in the DEXes that you want to include only and separate them by `,`. You can check out the full list [here](https://quote-api.jup.ag/v6/program-id-to-label).
	Dexes *DexesParameter `form:"dexes,omitempty" json:"dexes,omitempty"`

	// ExcludeDexes Default is that all DEXes are included. You can pass in the DEXes that you want to exclude and separate them by `,`. You can check out the full list [here](https://quote-api.jup.ag/v6/program-id-to-label).
	ExcludeDexes *ExcludeDexesParameter `form:"excludeDexes,omitempty" json:"excludeDexes,omitempty"`

	// RestrictIntermediateTokens Restrict intermediate tokens to a top token set that has stable liquidity. This will help to ease potential high slippage error rate when swapping with minimal impact on pricing.
	RestrictIntermediateTokens *RestrictIntermediateTokensParameter `form:"restrictIntermediateTokens,omitempty" json:"restrictIntermediateTokens,omitempty"`

	// OnlyDirectRoutes Default is false. Direct Routes limits Jupiter routing to single hop routes only.
	OnlyDirectRoutes *OnlyDirectRoutesParameter `form:"onlyDirectRoutes,omitempty" json:"onlyDirectRoutes,omitempty"`

	// AsLegacyTransaction Default is false. Instead of using versioned transaction, this will use the legacy transaction.
	AsLegacyTransaction *AsLegacyTransactionParameter `form:"asLegacyTransaction,omitempty" json:"asLegacyTransaction,omitempty"`

	// PlatformFeeBps If you want to charge the user a fee, you can specify the fee in BPS. Fee % is taken out of the output token.
	PlatformFeeBps *PlatformFeeBpsParameter `form:"platformFeeBps,omitempty" json:"platformFeeBps,omitempty"`

	// MaxAccounts Rough estimate of the max accounts to be used for the quote, so that you can compose with your own accounts
	MaxAccounts *MaxAccountsParameter `form:"maxAccounts,omitempty" json:"maxAccounts,omitempty"`
}

// GetQuoteParamsSwapMode defines parameters for GetQuote.
type GetQuoteParamsSwapMode string

// PostSwapJSONRequestBody defines body for PostSwap for application/json ContentType.
type PostSwapJSONRequestBody = SwapRequest

// PostSwapInstructionsJSONRequestBody defines body for PostSwapInstructions for application/json ContentType.
type PostSwapInstructionsJSONRequestBody = SwapRequest

// AsSwapRequestComputeUnitPriceMicroLamports0 returns the union data inside the SwapRequest_ComputeUnitPriceMicroLamports as a SwapRequestComputeUnitPriceMicroLamports0
func (t SwapRequest_ComputeUnitPriceMicroLamports) AsSwapRequestComputeUnitPriceMicroLamports0() (SwapRequestComputeUnitPriceMicroLamports0, error) {
	var body SwapRequestComputeUnitPriceMicroLamports0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSwapRequestComputeUnitPriceMicroLamports0 overwrites any union data inside the SwapRequest_ComputeUnitPriceMicroLamports as the provided SwapRequestComputeUnitPriceMicroLamports0
func (t *SwapRequest_ComputeUnitPriceMicroLamports) FromSwapRequestComputeUnitPriceMicroLamports0(v SwapRequestComputeUnitPriceMicroLamports0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSwapRequestComputeUnitPriceMicroLamports0 performs a merge with any union data inside the SwapRequest_ComputeUnitPriceMicroLamports, using the provided SwapRequestComputeUnitPriceMicroLamports0
func (t *SwapRequest_ComputeUnitPriceMicroLamports) MergeSwapRequestComputeUnitPriceMicroLamports0(v SwapRequestComputeUnitPriceMicroLamports0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSwapRequestComputeUnitPriceMicroLamports1 returns the union data inside the SwapRequest_ComputeUnitPriceMicroLamports as a SwapRequestComputeUnitPriceMicroLamports1
func (t SwapRequest_ComputeUnitPriceMicroLamports) AsSwapRequestComputeUnitPriceMicroLamports1() (SwapRequestComputeUnitPriceMicroLamports1, error) {
	var body SwapRequestComputeUnitPriceMicroLamports1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSwapRequestComputeUnitPriceMicroLamports1 overwrites any union data inside the SwapRequest_ComputeUnitPriceMicroLamports as the provided SwapRequestComputeUnitPriceMicroLamports1
func (t *SwapRequest_ComputeUnitPriceMicroLamports) FromSwapRequestComputeUnitPriceMicroLamports1(v SwapRequestComputeUnitPriceMicroLamports1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSwapRequestComputeUnitPriceMicroLamports1 performs a merge with any union data inside the SwapRequest_ComputeUnitPriceMicroLamports, using the provided SwapRequestComputeUnitPriceMicroLamports1
func (t *SwapRequest_ComputeUnitPriceMicroLamports) MergeSwapRequestComputeUnitPriceMicroLamports1(v SwapRequestComputeUnitPriceMicroLamports1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t SwapRequest_ComputeUnitPriceMicroLamports) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SwapRequest_ComputeUnitPriceMicroLamports) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSwapRequestPrioritizationFeeLamports0 returns the union data inside the SwapRequest_PrioritizationFeeLamports as a SwapRequestPrioritizationFeeLamports0
func (t SwapRequest_PrioritizationFeeLamports) AsSwapRequestPrioritizationFeeLamports0() (SwapRequestPrioritizationFeeLamports0, error) {
	var body SwapRequestPrioritizationFeeLamports0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSwapRequestPrioritizationFeeLamports0 overwrites any union data inside the SwapRequest_PrioritizationFeeLamports as the provided SwapRequestPrioritizationFeeLamports0
func (t *SwapRequest_PrioritizationFeeLamports) FromSwapRequestPrioritizationFeeLamports0(v SwapRequestPrioritizationFeeLamports0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSwapRequestPrioritizationFeeLamports0 performs a merge with any union data inside the SwapRequest_PrioritizationFeeLamports, using the provided SwapRequestPrioritizationFeeLamports0
func (t *SwapRequest_PrioritizationFeeLamports) MergeSwapRequestPrioritizationFeeLamports0(v SwapRequestPrioritizationFeeLamports0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSwapRequestPrioritizationFeeLamports1 returns the union data inside the SwapRequest_PrioritizationFeeLamports as a SwapRequestPrioritizationFeeLamports1
func (t SwapRequest_PrioritizationFeeLamports) AsSwapRequestPrioritizationFeeLamports1() (SwapRequestPrioritizationFeeLamports1, error) {
	var body SwapRequestPrioritizationFeeLamports1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSwapRequestPrioritizationFeeLamports1 overwrites any union data inside the SwapRequest_PrioritizationFeeLamports as the provided SwapRequestPrioritizationFeeLamports1
func (t *SwapRequest_PrioritizationFeeLamports) FromSwapRequestPrioritizationFeeLamports1(v SwapRequestPrioritizationFeeLamports1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSwapRequestPrioritizationFeeLamports1 performs a merge with any union data inside the SwapRequest_PrioritizationFeeLamports, using the provided SwapRequestPrioritizationFeeLamports1
func (t *SwapRequest_PrioritizationFeeLamports) MergeSwapRequestPrioritizationFeeLamports1(v SwapRequestPrioritizationFeeLamports1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t SwapRequest_PrioritizationFeeLamports) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SwapRequest_PrioritizationFeeLamports) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetIndexedRouteMap request
	GetIndexedRouteMap(ctx context.Context, params *GetIndexedRouteMapParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProgramIdToLabel request
	GetProgramIdToLabel(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetQuote request
	GetQuote(ctx context.Context, params *GetQuoteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSwapWithBody request with any body
	PostSwapWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSwap(ctx context.Context, body PostSwapJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSwapInstructionsWithBody request with any body
	PostSwapInstructionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSwapInstructions(ctx context.Context, body PostSwapInstructionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTokens request
	GetTokens(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetIndexedRouteMap(ctx context.Context, params *GetIndexedRouteMapParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIndexedRouteMapRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProgramIdToLabel(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProgramIdToLabelRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetQuote(ctx context.Context, params *GetQuoteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetQuoteRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSwapWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSwapRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSwap(ctx context.Context, body PostSwapJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSwapRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSwapInstructionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSwapInstructionsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSwapInstructions(ctx context.Context, body PostSwapInstructionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSwapInstructionsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTokens(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTokensRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetIndexedRouteMapRequest generates requests for GetIndexedRouteMap
func NewGetIndexedRouteMapRequest(server string, params *GetIndexedRouteMapParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/indexed-route-map")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OnlyDirectRoutes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "onlyDirectRoutes", runtime.ParamLocationQuery, *params.OnlyDirectRoutes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProgramIdToLabelRequest generates requests for GetProgramIdToLabel
func NewGetProgramIdToLabelRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/program-id-to-label")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetQuoteRequest generates requests for GetQuote
func NewGetQuoteRequest(server string, params *GetQuoteParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/quote")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inputMint", runtime.ParamLocationQuery, params.InputMint); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputMint", runtime.ParamLocationQuery, params.OutputMint); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.SlippageBps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "slippageBps", runtime.ParamLocationQuery, *params.SlippageBps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SwapMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "swapMode", runtime.ParamLocationQuery, *params.SwapMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Dexes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dexes", runtime.ParamLocationQuery, *params.Dexes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeDexes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeDexes", runtime.ParamLocationQuery, *params.ExcludeDexes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RestrictIntermediateTokens != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "restrictIntermediateTokens", runtime.ParamLocationQuery, *params.RestrictIntermediateTokens); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyDirectRoutes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "onlyDirectRoutes", runtime.ParamLocationQuery, *params.OnlyDirectRoutes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AsLegacyTransaction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asLegacyTransaction", runtime.ParamLocationQuery, *params.AsLegacyTransaction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PlatformFeeBps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "platformFeeBps", runtime.ParamLocationQuery, *params.PlatformFeeBps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxAccounts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxAccounts", runtime.ParamLocationQuery, *params.MaxAccounts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSwapRequest calls the generic PostSwap builder with application/json body
func NewPostSwapRequest(server string, body PostSwapJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSwapRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSwapRequestWithBody generates requests for PostSwap with any type of body
func NewPostSwapRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/swap")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSwapInstructionsRequest calls the generic PostSwapInstructions builder with application/json body
func NewPostSwapInstructionsRequest(server string, body PostSwapInstructionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSwapInstructionsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSwapInstructionsRequestWithBody generates requests for PostSwapInstructions with any type of body
func NewPostSwapInstructionsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/swap-instructions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTokensRequest generates requests for GetTokens
func NewGetTokensRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tokens")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetIndexedRouteMapWithResponse request
	GetIndexedRouteMapWithResponse(ctx context.Context, params *GetIndexedRouteMapParams, reqEditors ...RequestEditorFn) (*GetIndexedRouteMapResponse, error)

	// GetProgramIdToLabelWithResponse request
	GetProgramIdToLabelWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetProgramIdToLabelResponse, error)

	// GetQuoteWithResponse request
	GetQuoteWithResponse(ctx context.Context, params *GetQuoteParams, reqEditors ...RequestEditorFn) (*GetQuoteResponse, error)

	// PostSwapWithBodyWithResponse request with any body
	PostSwapWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSwapResponse, error)

	PostSwapWithResponse(ctx context.Context, body PostSwapJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSwapResponse, error)

	// PostSwapInstructionsWithBodyWithResponse request with any body
	PostSwapInstructionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSwapInstructionsResponse, error)

	PostSwapInstructionsWithResponse(ctx context.Context, body PostSwapInstructionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSwapInstructionsResponse, error)

	// GetTokensWithResponse request
	GetTokensWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTokensResponse, error)
}

type GetIndexedRouteMapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IndexedRouteMapResponse
}

// Status returns HTTPResponse.Status
func (r GetIndexedRouteMapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIndexedRouteMapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProgramIdToLabelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]string
}

// Status returns HTTPResponse.Status
func (r GetProgramIdToLabelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProgramIdToLabelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetQuoteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QuoteResponse
}

// Status returns HTTPResponse.Status
func (r GetQuoteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetQuoteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSwapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SwapResponse
}

// Status returns HTTPResponse.Status
func (r PostSwapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSwapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSwapInstructionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SwapInstructionsResponse
}

// Status returns HTTPResponse.Status
func (r PostSwapInstructionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSwapInstructionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTokensResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetIndexedRouteMapWithResponse request returning *GetIndexedRouteMapResponse
func (c *ClientWithResponses) GetIndexedRouteMapWithResponse(ctx context.Context, params *GetIndexedRouteMapParams, reqEditors ...RequestEditorFn) (*GetIndexedRouteMapResponse, error) {
	rsp, err := c.GetIndexedRouteMap(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIndexedRouteMapResponse(rsp)
}

// GetProgramIdToLabelWithResponse request returning *GetProgramIdToLabelResponse
func (c *ClientWithResponses) GetProgramIdToLabelWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetProgramIdToLabelResponse, error) {
	rsp, err := c.GetProgramIdToLabel(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProgramIdToLabelResponse(rsp)
}

// GetQuoteWithResponse request returning *GetQuoteResponse
func (c *ClientWithResponses) GetQuoteWithResponse(ctx context.Context, params *GetQuoteParams, reqEditors ...RequestEditorFn) (*GetQuoteResponse, error) {
	rsp, err := c.GetQuote(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetQuoteResponse(rsp)
}

// PostSwapWithBodyWithResponse request with arbitrary body returning *PostSwapResponse
func (c *ClientWithResponses) PostSwapWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSwapResponse, error) {
	rsp, err := c.PostSwapWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSwapResponse(rsp)
}

func (c *ClientWithResponses) PostSwapWithResponse(ctx context.Context, body PostSwapJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSwapResponse, error) {
	rsp, err := c.PostSwap(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSwapResponse(rsp)
}

// PostSwapInstructionsWithBodyWithResponse request with arbitrary body returning *PostSwapInstructionsResponse
func (c *ClientWithResponses) PostSwapInstructionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSwapInstructionsResponse, error) {
	rsp, err := c.PostSwapInstructionsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSwapInstructionsResponse(rsp)
}

func (c *ClientWithResponses) PostSwapInstructionsWithResponse(ctx context.Context, body PostSwapInstructionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSwapInstructionsResponse, error) {
	rsp, err := c.PostSwapInstructions(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSwapInstructionsResponse(rsp)
}

// GetTokensWithResponse request returning *GetTokensResponse
func (c *ClientWithResponses) GetTokensWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTokensResponse, error) {
	rsp, err := c.GetTokens(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTokensResponse(rsp)
}

// ParseGetIndexedRouteMapResponse parses an HTTP response from a GetIndexedRouteMapWithResponse call
func ParseGetIndexedRouteMapResponse(rsp *http.Response) (*GetIndexedRouteMapResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIndexedRouteMapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IndexedRouteMapResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetProgramIdToLabelResponse parses an HTTP response from a GetProgramIdToLabelWithResponse call
func ParseGetProgramIdToLabelResponse(rsp *http.Response) (*GetProgramIdToLabelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProgramIdToLabelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetQuoteResponse parses an HTTP response from a GetQuoteWithResponse call
func ParseGetQuoteResponse(rsp *http.Response) (*GetQuoteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetQuoteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QuoteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostSwapResponse parses an HTTP response from a PostSwapWithResponse call
func ParsePostSwapResponse(rsp *http.Response) (*PostSwapResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSwapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SwapResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostSwapInstructionsResponse parses an HTTP response from a PostSwapInstructionsWithResponse call
func ParsePostSwapInstructionsResponse(rsp *http.Response) (*PostSwapInstructionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSwapInstructionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SwapInstructionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTokensResponse parses an HTTP response from a GetTokensWithResponse call
func ParseGetTokensResponse(rsp *http.Response) (*GetTokensResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
