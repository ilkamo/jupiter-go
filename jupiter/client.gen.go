// Package jupiter provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package jupiter

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
)

// Defines values for SwapMode.
const (
	SwapModeExactIn  SwapMode = "ExactIn"
	SwapModeExactOut SwapMode = "ExactOut"
)

// Defines values for SwapRequestPrioritizationFeeLamportsPriorityLevelWithMaxLamportsPriorityLevel.
const (
	High     SwapRequestPrioritizationFeeLamportsPriorityLevelWithMaxLamportsPriorityLevel = "high"
	Medium   SwapRequestPrioritizationFeeLamportsPriorityLevelWithMaxLamportsPriorityLevel = "medium"
	VeryHigh SwapRequestPrioritizationFeeLamportsPriorityLevelWithMaxLamportsPriorityLevel = "veryHigh"
)

// Defines values for SwapModeParameter.
const (
	SwapModeParameterExactIn  SwapModeParameter = "ExactIn"
	SwapModeParameterExactOut SwapModeParameter = "ExactOut"
)

// Defines values for QuoteGetParamsSwapMode.
const (
	ExactIn  QuoteGetParamsSwapMode = "ExactIn"
	ExactOut QuoteGetParamsSwapMode = "ExactOut"
)

// AccountMeta defines model for AccountMeta.
type AccountMeta struct {
	IsSigner   bool   `json:"isSigner"`
	IsWritable bool   `json:"isWritable"`
	Pubkey     string `json:"pubkey"`
}

// Instruction defines model for Instruction.
type Instruction struct {
	Accounts  []AccountMeta `json:"accounts"`
	Data      string        `json:"data"`
	ProgramId string        `json:"programId"`
}

// PlatformFee defines model for PlatformFee.
type PlatformFee struct {
	Amount *string `json:"amount,omitempty"`
	FeeBps *uint64 `json:"feeBps,omitempty"`
}

// QuoteResponse defines model for QuoteResponse.
type QuoteResponse struct {
	ContextSlot *uint64 `json:"contextSlot,omitempty"`
	InAmount    string  `json:"inAmount"`
	InputMint   string  `json:"inputMint"`

	// OtherAmountThreshold - Calculated minimum output amount after accounting for `slippageBps` on the `outAmount` value
	// - Not used by `/swap` endpoint to build transaction
	OtherAmountThreshold string `json:"otherAmountThreshold"`

	// OutAmount - Calculated output amount from routing engine
	// - The value includes platform fees and DEX fees, excluding slippage
	OutAmount      string          `json:"outAmount"`
	OutputMint     string          `json:"outputMint"`
	PlatformFee    *PlatformFee    `json:"platformFee,omitempty"`
	PriceImpactPct string          `json:"priceImpactPct"`
	RoutePlan      []RoutePlanStep `json:"routePlan"`
	SlippageBps    uint64          `json:"slippageBps"`
	SwapMode       SwapMode        `json:"swapMode"`
	TimeTaken      *float32        `json:"timeTaken,omitempty"`
}

// RoutePlanStep defines model for RoutePlanStep.
type RoutePlanStep struct {
	Bps      *uint64  `json:"bps,omitempty"`
	Percent  uint64   `json:"percent"`
	SwapInfo SwapInfo `json:"swapInfo"`
}

// SwapInfo defines model for SwapInfo.
type SwapInfo struct {
	AmmKey     string  `json:"ammKey"`
	FeeAmount  string  `json:"feeAmount"`
	FeeMint    string  `json:"feeMint"`
	InAmount   string  `json:"inAmount"`
	InputMint  string  `json:"inputMint"`
	Label      *string `json:"label,omitempty"`
	OutAmount  string  `json:"outAmount"`
	OutputMint string  `json:"outputMint"`
}

// SwapInstructionsResponse defines model for SwapInstructionsResponse.
type SwapInstructionsResponse struct {
	// AddressLookupTableAddresses - The lookup table addresses if you are using versioned transaction.
	AddressLookupTableAddresses []string     `json:"addressLookupTableAddresses"`
	CleanupInstruction          *Instruction `json:"cleanupInstruction,omitempty"`

	// ComputeBudgetInstructions - To setup the compute budget for the transaction.
	ComputeBudgetInstructions []Instruction `json:"computeBudgetInstructions"`

	// OtherInstructions - If you set `{\"prioritizationFeeLamports\": {\"jitoTipLamports\": 5000}}`, you will see a custom tip instruction to Jito here.
	OtherInstructions *[]Instruction `json:"otherInstructions,omitempty"`

	// SetupInstructions - To setup required token accounts for the users.
	SetupInstructions []Instruction `json:"setupInstructions"`
	SwapInstruction   Instruction   `json:"swapInstruction"`
}

// SwapMode defines model for SwapMode.
type SwapMode string

// SwapRequest defines model for SwapRequest.
type SwapRequest struct {
	// AsLegacyTransaction - Builds a legacy transaction rather than the default versioned transaction
	// - Used together with `asLegacyTransaction` in `/quote`, otherwise the transaction might be too large
	AsLegacyTransaction *bool `json:"asLegacyTransaction,omitempty"`

	// BlockhashSlotsToExpiry - Pass in the number of slots we want the transaction to be valid for
	// - Example: If you pass in 10 slots, the transaction will be valid for ~400ms * 10 = approximately 4 seconds before it expires
	BlockhashSlotsToExpiry *uint64 `json:"blockhashSlotsToExpiry,omitempty"`

	// ComputeUnitPriceMicroLamports - To use an exact compute unit price to calculate priority fee
	// - `computeUnitLimit (1400000) * computeUnitPriceMicroLamports`
	// - We recommend using `prioritizationFeeLamports` and `dynamicComputeUnitLimit` instead of passing in your own compute unit price
	ComputeUnitPriceMicroLamports *uint64 `json:"computeUnitPriceMicroLamports,omitempty"`

	// DestinationTokenAccount - Public key of a token account that will be used to receive the token out of the swap
	// - If not provided, the signer's token account will be used
	// - If provided, we assume that the token account is already initialized
	DestinationTokenAccount *string `json:"destinationTokenAccount,omitempty"`

	// DynamicComputeUnitLimit - When enabled, it will do a swap simulation to get the compute unit used and set it in ComputeBudget's compute unit limit
	// - This incurs one extra RPC call to simulate this
	// - We recommend to enable this to estimate compute unit correctly and reduce priority fees needed or have higher chance to be included in a block
	DynamicComputeUnitLimit *bool `json:"dynamicComputeUnitLimit,omitempty"`

	// DynamicSlippage - When enabled, it estimates slippage and apply it in the swap transaction directly, overwriting the `slippageBps` parameter in the quote response.
	// - Used together with `dynamicSlippage` in `/quote`, otherwise the slippage used will be the one in the `/quote`'s `slippageBps`
	// - [See notes for more information](/docs/swap-api/send-swap-transaction#how-jupiter-estimates-slippage)
	DynamicSlippage *bool `json:"dynamicSlippage,omitempty"`

	// FeeAccount - An token account that will be used to collect fees
	// - The mint of the token account **can only be either the input or output mint of the swap**
	// - You no longer are required to use the Referral Program
	// - See [Add Fees](/docs/swap-api/add-fees-to-swap) guide for more details
	FeeAccount *string `json:"feeAccount,omitempty"`

	// Payer - Allow a custom payer to pay for the transaction fees and rent of token accounts
	// - Note that users can close their ATAs elsewhere and have you reopen them again, your fees should account for this
	Payer *string `json:"payer,omitempty"`

	// PrioritizationFeeLamports - To specify a level or amount of additional fees to prioritize the transaction
	// - It can be used for EITHER priority fee OR Jito tip (not both at the same time)
	// - If you want to include both, you will need to use `/swap-instructions` to add both at the same time
	PrioritizationFeeLamports *struct {
		// JitoTipLamports - Exact amount of tip to use in a tip instruction
		// - Refer to Jito docs on how to estimate the tip amount based on percentiles
		// - It has to be used together with a connection to a Jito RPC
		// - [See their docs](https://docs.jito.wtf/)
		JitoTipLamports              *uint64 `json:"jitoTipLamports,omitempty"`
		PriorityLevelWithMaxLamports *struct {
			// MaxLamports - Maximum lamports to cap the priority fee estimation, to prevent overpaying
			MaxLamports   *uint64                                                                        `json:"maxLamports,omitempty"`
			PriorityLevel *SwapRequestPrioritizationFeeLamportsPriorityLevelWithMaxLamportsPriorityLevel `json:"priorityLevel,omitempty"`
		} `json:"priorityLevelWithMaxLamports,omitempty"`
	} `json:"prioritizationFeeLamports,omitempty"`
	QuoteResponse QuoteResponse `json:"quoteResponse"`

	// SkipUserAccountsRpcCalls - When enabled, it will not do any additional RPC calls to check on required accounts
	// - The returned swap transaction will still attempt to create required accounts regardless if it exists or not
	SkipUserAccountsRpcCalls *bool `json:"skipUserAccountsRpcCalls,omitempty"`

	// TrackingAccount - Specify any public key that belongs to you to track the transactions
	// - Useful for integrators to get all the swap transactions from this public key
	// - Query the data using a block explorer like Solscan/SolanaFM or query like Dune/Flipside
	TrackingAccount *string `json:"trackingAccount,omitempty"`

	// UseSharedAccounts - The default is determined dynamically by the routing engine, allowing us to optimize for compute units, etc
	// - This enables the usage of shared program accounts, this is essential as complex routing will require multiple intermediate token accounts which the user might not have
	// - If true, you do not need to handle the creation of intermediate token accounts for the user
	// - Do note, shared accounts route will fail on some new AMMs (low liquidity token)
	UseSharedAccounts *bool  `json:"useSharedAccounts,omitempty"`
	UserPublicKey     string `json:"userPublicKey"`

	// WrapAndUnwrapSol - To automatically wrap/unwrap SOL in the transaction, as WSOL is an SPL token while native SOL is not
	// - When true, it will strictly use SOL amount to wrap it to swap, and each time after you swap, it will unwrap all WSOL back to SOL
	// - When false, it will strictly use WSOL amount to swap, and each time after you swap, it will not unwrap the WSOL back to SOL
	// - To set this parameter to false, you need to have the WSOL token account initialized
	// - Parameter will be ignored if `destinationTokenAccount` is set because the `destinationTokenAccount` may belong to a different user that we have no authority to close
	WrapAndUnwrapSol *bool `json:"wrapAndUnwrapSol,omitempty"`
}

// SwapRequestPrioritizationFeeLamportsPriorityLevelWithMaxLamportsPriorityLevel defines model for SwapRequest.PrioritizationFeeLamports.PriorityLevelWithMaxLamports.PriorityLevel.
type SwapRequestPrioritizationFeeLamportsPriorityLevelWithMaxLamportsPriorityLevel string

// SwapResponse defines model for SwapResponse.
type SwapResponse struct {
	LastValidBlockHeight      uint64  `json:"lastValidBlockHeight"`
	PrioritizationFeeLamports *uint64 `json:"prioritizationFeeLamports,omitempty"`
	SwapTransaction           string  `json:"swapTransaction"`
}

// AmountParameter defines model for AmountParameter.
type AmountParameter = uint64

// AsLegacyTransactionParameter defines model for AsLegacyTransactionParameter.
type AsLegacyTransactionParameter = bool

// DexesParameter defines model for DexesParameter.
type DexesParameter = []string

// DynamicSlippage defines model for DynamicSlippage.
type DynamicSlippage = bool

// ExcludeDexesParameter defines model for ExcludeDexesParameter.
type ExcludeDexesParameter = []string

// InputMintParameter defines model for InputMintParameter.
type InputMintParameter = string

// MaxAccountsParameter defines model for MaxAccountsParameter.
type MaxAccountsParameter = uint64

// OnlyDirectRoutesParameter defines model for OnlyDirectRoutesParameter.
type OnlyDirectRoutesParameter = bool

// OutputMintParameter defines model for OutputMintParameter.
type OutputMintParameter = string

// PlatformFeeBpsParameter defines model for PlatformFeeBpsParameter.
type PlatformFeeBpsParameter = uint64

// RestrictIntermediateTokensParameter defines model for RestrictIntermediateTokensParameter.
type RestrictIntermediateTokensParameter = bool

// SlippageParameter defines model for SlippageParameter.
type SlippageParameter = uint64

// SwapModeParameter defines model for SwapModeParameter.
type SwapModeParameter string

// QuoteGetParams defines parameters for QuoteGet.
type QuoteGetParams struct {
	InputMint  InputMintParameter  `form:"inputMint" json:"inputMint"`
	OutputMint OutputMintParameter `form:"outputMint" json:"outputMint"`

	// Amount - Raw amount to swap (before decimals)
	// - Input Amount if `SwapMode=ExactIn`
	// - Output Amount if `SwapMode=ExactOut`
	Amount      AmountParameter    `form:"amount" json:"amount"`
	SlippageBps *SlippageParameter `form:"slippageBps,omitempty" json:"slippageBps,omitempty"`

	// SwapMode - ExactOut is for supporting use cases where you need an exact output amount, like using [Swap API as a payment service](/docs/swap-api/payments-through-swap)
	// - In the case of `ExactIn`, the slippage is on the output token
	// - In the case of `ExactOut`, the slippage is on the input token
	// - Not all AMMs support `ExactOut`: Currently only Orca Whirlpool, Raydium CLMM, Raydium CPMM
	SwapMode *QuoteGetParamsSwapMode `form:"swapMode,omitempty" json:"swapMode,omitempty"`

	// Dexes - Multiple DEXes can be pass in by comma separating them
	// - For example: `dexes=Raydium,Orca+V2,Meteora+DLMM`
	// - If a DEX is indicated, the route will **only use** that DEX
	// - [Full list of DEXes here](https://lite-api.jup.ag/swap/v1/program-id-to-label)
	Dexes *DexesParameter `form:"dexes,omitempty" json:"dexes,omitempty"`

	// ExcludeDexes - Multiple DEXes can be pass in by comma separating them
	// - For example: `excludeDexes=Raydium,Orca+V2,Meteora+DLMM`
	// - If a DEX is indicated, the route will **not use** that DEX
	// - [Full list of DEXes here](https://lite-api.jup.ag/swap/v1/program-id-to-label)
	ExcludeDexes *ExcludeDexesParameter `form:"excludeDexes,omitempty" json:"excludeDexes,omitempty"`

	// RestrictIntermediateTokens - Restrict intermediate tokens within a route to a set of more stable tokens
	// - This will help to reduce exposure to potential high slippage routes
	RestrictIntermediateTokens *RestrictIntermediateTokensParameter `form:"restrictIntermediateTokens,omitempty" json:"restrictIntermediateTokens,omitempty"`

	// OnlyDirectRoutes - Direct Routes limits Jupiter routing to single hop routes only
	// - This may result in worse routes
	OnlyDirectRoutes *OnlyDirectRoutesParameter `form:"onlyDirectRoutes,omitempty" json:"onlyDirectRoutes,omitempty"`

	// AsLegacyTransaction - Instead of using versioned transaction, this will use the legacy transaction
	AsLegacyTransaction *AsLegacyTransactionParameter `form:"asLegacyTransaction,omitempty" json:"asLegacyTransaction,omitempty"`

	// PlatformFeeBps - Take fees in basis points
	// - Used together with `feeAccount` in /swap, see [Adding Fees](/docs/swap-api/add-fees-to-swap) guide
	PlatformFeeBps *PlatformFeeBpsParameter `form:"platformFeeBps,omitempty" json:"platformFeeBps,omitempty"`

	// MaxAccounts - Rough estimate of the max accounts to be used for the quote
	// - Useful if composing your own transaction or to be more precise in resource accounting for better routes
	MaxAccounts *MaxAccountsParameter `form:"maxAccounts,omitempty" json:"maxAccounts,omitempty"`

	// DynamicSlippage - If true, `slippageBps` will be overriden by Dynamic Slippage's estimated value
	// - The value is returned in `/swap` endpoint
	DynamicSlippage *DynamicSlippage `form:"dynamicSlippage,omitempty" json:"dynamicSlippage,omitempty"`
}

// QuoteGetParamsSwapMode defines parameters for QuoteGet.
type QuoteGetParamsSwapMode string

// SwapPostJSONRequestBody defines body for SwapPost for application/json ContentType.
type SwapPostJSONRequestBody = SwapRequest

// SwapInstructionsPostJSONRequestBody defines body for SwapInstructionsPost for application/json ContentType.
type SwapInstructionsPostJSONRequestBody = SwapRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ProgramIdToLabelGet request
	ProgramIdToLabelGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// QuoteGet request
	QuoteGet(ctx context.Context, params *QuoteGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SwapPostWithBody request with any body
	SwapPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SwapPost(ctx context.Context, body SwapPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SwapInstructionsPostWithBody request with any body
	SwapInstructionsPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SwapInstructionsPost(ctx context.Context, body SwapInstructionsPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ProgramIdToLabelGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProgramIdToLabelGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QuoteGet(ctx context.Context, params *QuoteGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQuoteGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SwapPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSwapPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SwapPost(ctx context.Context, body SwapPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSwapPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SwapInstructionsPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSwapInstructionsPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SwapInstructionsPost(ctx context.Context, body SwapInstructionsPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSwapInstructionsPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewProgramIdToLabelGetRequest generates requests for ProgramIdToLabelGet
func NewProgramIdToLabelGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/program-id-to-label")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQuoteGetRequest generates requests for QuoteGet
func NewQuoteGetRequest(server string, params *QuoteGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/quote")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inputMint", runtime.ParamLocationQuery, params.InputMint); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputMint", runtime.ParamLocationQuery, params.OutputMint); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.SlippageBps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "slippageBps", runtime.ParamLocationQuery, *params.SlippageBps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SwapMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "swapMode", runtime.ParamLocationQuery, *params.SwapMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Dexes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dexes", runtime.ParamLocationQuery, *params.Dexes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeDexes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeDexes", runtime.ParamLocationQuery, *params.ExcludeDexes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RestrictIntermediateTokens != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "restrictIntermediateTokens", runtime.ParamLocationQuery, *params.RestrictIntermediateTokens); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyDirectRoutes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "onlyDirectRoutes", runtime.ParamLocationQuery, *params.OnlyDirectRoutes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AsLegacyTransaction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asLegacyTransaction", runtime.ParamLocationQuery, *params.AsLegacyTransaction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PlatformFeeBps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "platformFeeBps", runtime.ParamLocationQuery, *params.PlatformFeeBps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxAccounts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxAccounts", runtime.ParamLocationQuery, *params.MaxAccounts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DynamicSlippage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dynamicSlippage", runtime.ParamLocationQuery, *params.DynamicSlippage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSwapPostRequest calls the generic SwapPost builder with application/json body
func NewSwapPostRequest(server string, body SwapPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSwapPostRequestWithBody(server, "application/json", bodyReader)
}

// NewSwapPostRequestWithBody generates requests for SwapPost with any type of body
func NewSwapPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/swap")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSwapInstructionsPostRequest calls the generic SwapInstructionsPost builder with application/json body
func NewSwapInstructionsPostRequest(server string, body SwapInstructionsPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSwapInstructionsPostRequestWithBody(server, "application/json", bodyReader)
}

// NewSwapInstructionsPostRequestWithBody generates requests for SwapInstructionsPost with any type of body
func NewSwapInstructionsPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/swap-instructions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ProgramIdToLabelGetWithResponse request
	ProgramIdToLabelGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ProgramIdToLabelGetResponse, error)

	// QuoteGetWithResponse request
	QuoteGetWithResponse(ctx context.Context, params *QuoteGetParams, reqEditors ...RequestEditorFn) (*QuoteGetResponse, error)

	// SwapPostWithBodyWithResponse request with any body
	SwapPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SwapPostResponse, error)

	SwapPostWithResponse(ctx context.Context, body SwapPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SwapPostResponse, error)

	// SwapInstructionsPostWithBodyWithResponse request with any body
	SwapInstructionsPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SwapInstructionsPostResponse, error)

	SwapInstructionsPostWithResponse(ctx context.Context, body SwapInstructionsPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SwapInstructionsPostResponse, error)
}

type ProgramIdToLabelGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]string
}

// Status returns HTTPResponse.Status
func (r ProgramIdToLabelGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProgramIdToLabelGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type QuoteGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QuoteResponse
}

// Status returns HTTPResponse.Status
func (r QuoteGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QuoteGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SwapPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SwapResponse
}

// Status returns HTTPResponse.Status
func (r SwapPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SwapPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SwapInstructionsPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SwapInstructionsResponse
}

// Status returns HTTPResponse.Status
func (r SwapInstructionsPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SwapInstructionsPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ProgramIdToLabelGetWithResponse request returning *ProgramIdToLabelGetResponse
func (c *ClientWithResponses) ProgramIdToLabelGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ProgramIdToLabelGetResponse, error) {
	rsp, err := c.ProgramIdToLabelGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProgramIdToLabelGetResponse(rsp)
}

// QuoteGetWithResponse request returning *QuoteGetResponse
func (c *ClientWithResponses) QuoteGetWithResponse(ctx context.Context, params *QuoteGetParams, reqEditors ...RequestEditorFn) (*QuoteGetResponse, error) {
	rsp, err := c.QuoteGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQuoteGetResponse(rsp)
}

// SwapPostWithBodyWithResponse request with arbitrary body returning *SwapPostResponse
func (c *ClientWithResponses) SwapPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SwapPostResponse, error) {
	rsp, err := c.SwapPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSwapPostResponse(rsp)
}

func (c *ClientWithResponses) SwapPostWithResponse(ctx context.Context, body SwapPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SwapPostResponse, error) {
	rsp, err := c.SwapPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSwapPostResponse(rsp)
}

// SwapInstructionsPostWithBodyWithResponse request with arbitrary body returning *SwapInstructionsPostResponse
func (c *ClientWithResponses) SwapInstructionsPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SwapInstructionsPostResponse, error) {
	rsp, err := c.SwapInstructionsPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSwapInstructionsPostResponse(rsp)
}

func (c *ClientWithResponses) SwapInstructionsPostWithResponse(ctx context.Context, body SwapInstructionsPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SwapInstructionsPostResponse, error) {
	rsp, err := c.SwapInstructionsPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSwapInstructionsPostResponse(rsp)
}

// ParseProgramIdToLabelGetResponse parses an HTTP response from a ProgramIdToLabelGetWithResponse call
func ParseProgramIdToLabelGetResponse(rsp *http.Response) (*ProgramIdToLabelGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProgramIdToLabelGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseQuoteGetResponse parses an HTTP response from a QuoteGetWithResponse call
func ParseQuoteGetResponse(rsp *http.Response) (*QuoteGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &QuoteGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QuoteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSwapPostResponse parses an HTTP response from a SwapPostWithResponse call
func ParseSwapPostResponse(rsp *http.Response) (*SwapPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SwapPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SwapResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSwapInstructionsPostResponse parses an HTTP response from a SwapInstructionsPostWithResponse call
func ParseSwapInstructionsPostResponse(rsp *http.Response) (*SwapInstructionsPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SwapInstructionsPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SwapInstructionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
